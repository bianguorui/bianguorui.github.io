<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>it&#39;s a good day!</title>
      <link href="/archives/bc5637dd.html"/>
      <url>/archives/bc5637dd.html</url>
      
        <content type="html"><![CDATA[<h1 id="hello"><a href="#hello" class="headerlink" title="hello!"></a>hello!</h1><p>it’s a good day! I’m back!</p><p>test again!!!</p><p>test one again!</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法之美》笔记:栈、队列</title>
      <link href="/archives/1e09e2bb.html"/>
      <url>/archives/1e09e2bb.html</url>
      
        <content type="html"><![CDATA[<p>这是4.26的测试。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法之美》笔记:排序（上）</title>
      <link href="/archives/8ab394f2.html"/>
      <url>/archives/8ab394f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="11-排序（上）"><a href="#11-排序（上）" class="headerlink" title="11 | 排序（上）"></a>11 | 排序（上）</h1><p>开篇先给出一个问题：<strong>插入排序和冒泡排序的时间复杂度相同，都是 O(n^2)，在实际的软件开发里，为什么我们更倾向于使用插入排序算法而不是冒泡排序算法呢？</strong></p><p>今天我们先看三个排序算法：冒泡排序、插入排序和选择排序。</p><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><ul><li>最好情况、最坏情况、平均情况时间复杂度</li><li>时间复杂度的系数、常数、低阶</li><li>比较次数和交换（或移动）次数</li></ul><h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>内存消耗可以通过空间复杂度来衡量，但是针对排序算法，我们还有一个重要概念，<strong>原地排序</strong>。原地排序算法，是指空间复杂度为O（1）的排序算法。今天讲的三种算法都是原地排序算法。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p><strong>稳定性</strong>这个概念是说，如果待排序的序列中如果存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序保持不变。</p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。一次冒泡会让至少一个元素移动到它应该在的位置，重复 n 次，就完成了 n 个数据的排序工作。</p><p><img src="https://z1.ax1x.com/2023/11/14/piYmtjH.png"></p><p>当然，冒泡排序还可以优化，当某次冒泡排序已经没有数据交换时，说明已经达到完全有序，可以不用进行后续的冒泡排序。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bubbleSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="literal">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>冒泡排序是原地排序算法</li><li>冒泡排序是稳定的排序算法</li><li>冒泡排序时间复杂度为O（n^2)</li></ul><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>一个有序数组，我们往里面添加一个新的数据后，只要遍历数组，找到数据应该插入的位置将其插入即可。</p><p><img src="https://z1.ax1x.com/2023/11/14/piYmT8U.png"></p><p>而插入排序是将数组中的数据分为两个区间，已排序区间和未排序区间。初始已排序区间只有一个，就是数组中的第一个元素。<strong>插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的区间进行插入，并保证已排序区间一直有序。</strong>重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>下图中，左侧为已排序区间，右侧为未排序区间。</p><p><img src="https://z1.ax1x.com/2023/11/14/piYmx56.png"></p><p>插入排序也包含两种操作，一种是<strong>元素的比较</strong>，一种是<strong>元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。</p><p>具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] a, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> a[i];</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><ul><li>插入排序是原地排序算法</li><li>插入排序是稳定的排序算法</li><li>插入排序的时间复杂度是O(n^2)</li></ul><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路类似插入排序，也分为已排序区间和未排序区间。但是选择排序每次会从未排序区间中找到最小的元素，将其放到已排序区间的末尾。</p><p><img src="https://z1.ax1x.com/2023/11/14/piYnlrj.png"></p><p>小结：</p><ul><li>选择排序是一种原地排序算法</li><li>选择排序是<strong>不稳定</strong>的排序算法</li><li>选择排序的时间复杂度为 O(n^2)</li></ul><p>现在我们来看开篇的问题：冒泡排序和插入排序的时间复杂度都是 O(n2)，都是原地排序算法，为什么插入排序要比冒泡排序更受欢迎呢？</p><p>主要在冒泡排序的数据交换比插入排序的数据移动要复杂，冒泡排序需要3个赋值操作，插入排序需要1个。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">   <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> a[j];</span><br><span class="line">   a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p><p>所以说，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是O(n^2)，但是将性能优化做到极致的话肯定首选插入排序。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p><img src="https://z1.ax1x.com/2023/11/14/piYnRzD.png"></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《数据结构与算法之美》笔记:栈、队列</title>
      <link href="/archives/1e09e2bb.html"/>
      <url>/archives/1e09e2bb.html</url>
      
        <content type="html"><![CDATA[<h3 id="08-栈"><a href="#08-栈" class="headerlink" title="08 | 栈"></a>08 | 栈</h3><p><strong>“栈”结构就是后进者先出，先进者后出。</strong> 还有，<strong>栈是一种“操作受限”的线性表</strong>，只允许在一端插入和删除数据。</p><h4 id="如何实现一个栈？"><a href="#如何实现一个栈？" class="headerlink" title="如何实现一个栈？"></a>如何实现一个栈？</h4><p>栈的主要操作有两个，入栈和出栈。</p><p>栈的实现可以用数组，可以用链表。用数组实现的叫<strong>顺序栈</strong>，用链表实现的叫<strong>链式栈</strong>。</p><p>用Java代码实现的顺序栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayStack</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> n;           <span class="comment">// 栈的大小</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 初始化数组，申请一个大小为 n 的数组空间</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayStack</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.items = <span class="keyword">new</span> <span class="title class_">String</span>[n];</span><br><span class="line">    <span class="built_in">this</span>.n = n;</span><br><span class="line">    <span class="built_in">this</span>.count = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 入栈操作</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">push</span><span class="params">(String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 数组空间不够了，直接返回 false，入栈失败。</span></span><br><span class="line">    <span class="keyword">if</span> (count == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 将 item 放到下标为 count 的位置，并且 count 加一</span></span><br><span class="line">    items[count] = item;</span><br><span class="line">    ++count;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 出栈操作</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 栈为空，则直接返回 null</span></span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> items[count-<span class="number">1</span>];</span><br><span class="line">    --count;</span><br><span class="line">    <span class="keyword">return</span> tmp;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栈操作的时间复杂度和空间复杂度都是O(1)。</p><h4 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h4><p>基于数组实现的栈是固定大小的，当栈满之后就无法往栈里添加数据了。链式栈虽然大小不受限，但是要存储next指针，内存消耗较大，所有可以基于数组实现一个动态扩展的栈。</p><p>当数组空间不够时就重新申请一块更大的内存，将原来数组中的数据通通拷贝过去。这样就实现了一个支持动态扩展的数组。要实现支持动态扩展的栈就是底层需要一个支持动态扩展的数组。</p><p><img src="C:\Users\a\Desktop\知识沉淀\数据结构与算法之美笔记\img\231101_1.png"></p><h4 id="栈的几种应用场景"><a href="#栈的几种应用场景" class="headerlink" title="栈的几种应用场景"></a>栈的几种应用场景</h4><ul><li>函数调用</li><li>表达式求值</li><li>括号匹配</li></ul><h3 id="09-队列"><a href="#09-队列" class="headerlink" title="09 | 队列"></a>09 | 队列</h3><p>队列这个概念就是我们平时生活中的排队买东西的场景，先来的人先买，后面的人站在后面排队。</p><p><strong>队列，先进者先出。</strong></p><p>队列的两个基本操作：入队和出队。入队，放一个数据到队列尾部，出队，从队列头部取一个元素。</p><p><img src="C:\Users\a\Desktop\知识沉淀\数据结构与算法之美笔记\img\231101_2.png"></p><h4 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h4><p>同栈一样，用数组实现的队列叫<strong>顺序队列</strong>，用链表实现的队列叫<strong>链式队列</strong>。</p><p>用Java实现基于数组的顺序队列方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArrayQueue</span> &#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ArrayQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    items = <span class="keyword">new</span> <span class="title class_">String</span>[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 tail == n 表示队列已经满了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">// 为了让其他语言的同学看的更加明确，把 -- 操作放到单独一行来写了</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> items[head];</span><br><span class="line">    ++head;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>队列需要两个指针：一个是head指针，指向队头；一个是tail指针，指向队尾。</p><p>如下图，head指针指向下标为0的位置，tail指针指向下标为4的位置。</p><p><img src="https://z1.ax1x.com/2023/11/01/piuM55j.png"></p><p>调用两次出队操作之后，队列中的head指针指向下标为2的位置，tail指针仍指向下标为4的位置。</p><p><img src="https://z1.ax1x.com/2023/11/01/piuMqMV.png"></p><p>这时，如果我们不停进行的入队和出队操作，head和tail都会持续往后移动。当tail移到最右边的时候，就无法往队列中的添加数据了，这可怎么办呢？</p><p>这时，我们就需要进行<strong>数据搬移</strong>。每次入队时，集中触发一次数据的搬移操作，保持出队函数dequeue()不变，改造入队函数enqueue()的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 入队操作，将 item 放入队尾</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(String item)</span> &#123;</span><br><span class="line">  <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">  <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">    <span class="comment">// tail ==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 数据搬移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> head; i &lt; tail; ++i) &#123;</span><br><span class="line">      items[i-head] = items[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搬移完之后重新更新 head 和 tail</span></span><br><span class="line">    tail -= head;</span><br><span class="line">    head = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  items[tail] = item;</span><br><span class="line">  ++tail;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们看到，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置。</p><p><img src="https://z1.ax1x.com/2023/11/01/piuQ1L8.png"></p><h4 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h4><p>用数组来实现队列，在tail &#x3D;&#x3D; n时，会有数据搬移操作，这样入队操作就受到了影响。而循环队列就可以避免数据迁移的问题。</p><p><img src="https://z1.ax1x.com/2023/11/01/piulwhd.png"></p><p>我们可以看到，图中这个队列的大小为 8，当前 head&#x3D;4，tail&#x3D;7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a，b 依次入队之后，循环队列中的元素就变成了下面的样子：</p><p><img src="https://z1.ax1x.com/2023/11/01/piulD1I.png"></p><p>写出循环队列的实现代码，最重要的就是确定好<strong>队空和队满的判定条件</strong>。</p><p>针对循环队列：</p><ul><li><p><strong>队列为空</strong>的判定条件是：head &#x3D;&#x3D; tail</p></li><li><p><strong>队列为满</strong>的判定条件是：(tail + 1) % n &#x3D;&#x3D; head</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CircularQueue</span> &#123;</span><br><span class="line">  <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">  <span class="keyword">private</span> String[] items;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">CircularQueue</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    items = <span class="keyword">new</span> <span class="title class_">String</span>[capacity];</span><br><span class="line">    n = capacity;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 入队</span></span><br><span class="line">  <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enqueue</span><span class="params">(String item)</span> &#123;</span><br><span class="line">    <span class="comment">// 队列满了</span></span><br><span class="line">    <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 出队</span></span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">dequeue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">    <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ret</span> <span class="operator">=</span> items[head];</span><br><span class="line">    head = (head + <span class="number">1</span>) % n;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h4><p><strong>阻塞队列</strong>就是在队列基础上增加了<strong>阻塞</strong>操作。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回。</p><p><img src="https://z1.ax1x.com/2023/11/01/piul49s.png"></p><p>线程安全的队列我们叫作<strong>并发队列</strong>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列。这也是循环队列比链式队列应用更加广泛的原因。</p><h4 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h4><p>队列最大的特点是<strong>先进先出</strong>，主要的两个操作就是入队和出队。</p><p>用数组实现的叫顺序队列，用链表实现的叫链式队列。特别是长得像一个环的循环队列。在数组实现队列的时候，会有数据搬移操作，要想解决数据搬移的问题，我们就需要像环一样的循环队列。</p><p>还有几种高级的队列结构，阻塞队列、并发队列，底层都还是队列这种数据结构，只不过在之上附加了很多其他功能。阻塞队列就是入队、出队操作可以阻塞，并发队列就是队列的操作多线程安全。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下IO模式和IO多路复用详解</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下IO模式和IO多路复用详解"><a href="#Linux下IO模式和IO多路复用详解" class="headerlink" title="Linux下IO模式和IO多路复用详解"></a>Linux下IO模式和IO多路复用详解</h1><p>今天我们来谈一谈Linux系统中的IO模式和IO多路复用。</p><h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><p>首先，我们要知道对于一次IO操作，操作系统需要干什么？</p><p>在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中，即数据会先拷贝到操作系统内核的缓冲区中，然后才将操作系统内核的数据缓冲区拷贝到应用程序的地址空间。当然，这种机制也有<strong>缺点</strong> ：数据在传输过程中需要在应用程序地址空间和内核进行多次的数据拷贝操作，这对于CPU和内存的开销是非常大的。</p><p>一次典型的网络IO调用分为两个阶段，分别是“数据就绪”和“数据读写”。数据就绪阶段分为<strong>阻塞</strong>和<strong>非阻塞</strong>，表现结果就是，阻塞当前线程或是直接返回。数据读写阶段分为<strong>同步</strong>和<strong>异步</strong>。</p><p>其中，同步表示A向B请求调用一个网路IO接口时，数据读写部分都是由A自己一个人完成的（不管是阻塞和非阻塞）；异步表示A向B请求调用一个网络IO接口时，向B传入请求的事件以及事件发生时通知的方式，A就可以去处理其他逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，<strong>通知</strong>A处理结果。在异步处理逻辑中，一定要关注通知二字，这是区分是同步和异步的重要的一点。</p><p>因此，Linux系统中产生了下面5种网络模式：</p><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ul><h3 id="阻塞IO（blocking-IO）"><a href="#阻塞IO（blocking-IO）" class="headerlink" title="阻塞IO（blocking IO）"></a>阻塞IO（blocking IO）</h3><p><img src="https://z1.ax1x.com/2023/10/10/pPzlRdH.png" alt="阻塞IO"></p><p>在Linux中，默认情况下所有socket都是阻塞的。当调用read系统调用时，kernel就开始了第一阶段：数据准备。kernel就会等待数据的到来，也就是数据被拷贝到操作内核是需要一个过程的，而在用户进程这边，整个进程会被阻塞（进程自己选择的结果）。当kernel等到数据准备好了，就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程解除阻塞状态，重新运行起来。</p><h3 id="非阻塞IO（nonblocking-IO）"><a href="#非阻塞IO（nonblocking-IO）" class="headerlink" title="非阻塞IO（nonblocking IO）"></a>非阻塞IO（nonblocking IO）</h3><p><img src="https://z1.ax1x.com/2023/10/10/pPztT4e.png" alt="非阻塞IO"></p><p>在Linux中，socket可以设置为非阻塞IO模式。非阻塞IO模式下的流程如上所示。</p><p>当应用进程进行read操作时，如果kernel中的数据没准备好，它并不是阻塞应用进程，而是立刻返回EAGAIN错误代码（在read操作时，表示取文件&#x2F;设备时资源临时不可用,需要重试读取操作）。从应用进程的角度来看，应用进程发起一个read操作后，并不需要等待，而是马上得到了一个结果。应用进程判断结果是一个error时，它就知道kernel还没准备好数据，于是再次发起read操作。一旦kernel中的数据准备好了，并再次收到了应用进程的read系统调用，就会马上将数据从内核空间拷贝到用户空间，然后返回，应用处理数据。</p><p>所以说，非阻塞IO的特点是用户进程不断地<strong>轮询</strong>kernel，数据准备好了没有。</p><h3 id="IO多路复用（-IO-multiplexing）"><a href="#IO多路复用（-IO-multiplexing）" class="headerlink" title="IO多路复用（ IO multiplexing）"></a>IO多路复用（ IO multiplexing）</h3><p><img src="https://z1.ax1x.com/2023/10/10/pPzN6Vf.md.png" alt="IO多路复用"></p><p>IO多路复用就是我们常说<strong>select</strong>、<strong>poll</strong>、<strong>epoll</strong>，这里我们先提前说一下，这三种IO多路复用接口都是<strong>同步IO</strong>，请谨记。</p><p>select&#x2F;epoll的好处是单个process就可以同时处理多个网络连接的IO。IO多路复用的基本原理就是select、poll、epoll这些接口会不断地轮询所有的socket，当某个socket有数据到达了，就告诉用户进程。当应用进程调用了select，那整个进程都会被阻塞，与此同时，kernel会“监视”所有select负责的socket，当其中的任何一个socket的数据准备好了，select就会返回。应用进程就接着调用read操作，将数据从kernel拷贝到应用进程。</p><h3 id="信号驱动IO（signal-driven）"><a href="#信号驱动IO（signal-driven）" class="headerlink" title="信号驱动IO（signal-driven）"></a>信号驱动IO（signal-driven）</h3><p><img src="https://z1.ax1x.com/2023/10/11/pPzUJQs.md.png" alt="信号驱动"></p><p>内核在第一个阶段是异步，在第二个阶段是同步。与非阻塞IO的区别在于它提供了消息通知机制，不需要应用进程来不断地轮询检查，减少了系统API的调用次数，提高了效率。</p><h3 id="异步IO（asynchronous）"><a href="#异步IO（asynchronous）" class="headerlink" title="异步IO（asynchronous）"></a>异步IO（asynchronous）</h3><p><img src="https://z1.ax1x.com/2023/10/11/pPzUBYF.md.png" alt="异步IO"></p><p>应用进程发起read操作后，就去做其他事情了，然后就等待将kerne发送信号l通知应用进程数据准备好了就行，告诉应用进程可以进行read操作。</p><h2 id="IO多路复用之select、poll、epoll详解"><a href="#IO多路复用之select、poll、epoll详解" class="headerlink" title="IO多路复用之select、poll、epoll详解"></a>IO多路复用之select、poll、epoll详解</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>下面我们来看select函数的功能和调用顺序。</p><p>使用select函数时可以将多个文件描述符集中到一起统一监视。select函数的调用方法和顺序如下所示：</p><p><img src="https://z1.ax1x.com/2023/10/11/pPzXH0J.png" alt="select函数调用过程"></p><p>由图可以看出，在调用select函数之前需要一些准备工作，调查后还需要查看结果，下面我们根据调用顺序逐一进行讲解。</p><h4 id="设置文件描述符"><a href="#设置文件描述符" class="headerlink" title="设置文件描述符"></a>设置文件描述符</h4><p>fd_set数组变量就是用来将要监视的文件描述符集中到一起的变量，该数组是存有0和1的<strong>位数组</strong>。</p><p><img src="https://z1.ax1x.com/2023/10/11/pPzjHv8.png"></p><p>最左端的位表示文件描述符0，如果该位设置为1，则表示该文件描述符是监视对象。由图中很明显看出文件描述符1和3是监视对象。</p><blockquote><p><strong>注意</strong> ：针对fd_set变量的操作都是以位为单位进行操作的，所以不能直接将文件描述符的数字注册到fd_set变量中。</p></blockquote><p>实际上，在fd_set变量的注册中或更改值都是通过下列宏进行完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(fd_set* fdset): 将fd_set变量的所有位初始化为0</span><br><span class="line">FD_SET(int fd, fd_set* fdset): 在参数fdset指向的变量中注册文件描述符fd的信息</span><br><span class="line">FD_CLR(int fd, fd_set* fdset): 从参数fdset指向的变量中清除文件描述符fd1的信息</span><br><span class="line">FD_ISSET(int fd, fd_set* fdset): 若参数fdset指向的变量中包含文件描述符fd的信息，则返回“真”</span><br></pre></td></tr></table></figure><p>上述函数中，FD_ISSET函数用来验证select函数的调用结果。</p><h4 id="设置检查（监视）范围及超时"><a href="#设置检查（监视）范围及超时" class="headerlink" title="设置检查（监视）范围及超时"></a>设置检查（监视）范围及超时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval* timeout)</span>;</span><br><span class="line"><span class="comment">//成功时返回大于0的值，失败时返回-1</span></span><br><span class="line"><span class="comment">//各参数解释：</span></span><br><span class="line"><span class="comment">//maxfd:监视对象文件描述符数量</span></span><br><span class="line"><span class="comment">//readset: 将所有关注“是否存在待读取数据”文件描述符注册到fd_set变量，并传递其地址值</span></span><br><span class="line"><span class="comment">//writeset: 将所有关注“是否可传输无阻塞数据”文件描述符注册到fd_set变量，并传递其地址值</span></span><br><span class="line"><span class="comment">//exceptset: 将所有关注“是否发生异常”文件描述符注册到fd_set变量，并传递其地址值</span></span><br><span class="line"><span class="comment">//timeout: 调用select函数后，为防止陷入无限阻塞的状态，传递超时（time-out）信息</span></span><br><span class="line"><span class="comment">//返回值：发生错误时返回-1，超时返回0.因发生关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。</span></span><br></pre></td></tr></table></figure><p>在调用select函数前，需要决定下面2件事</p><ul><li>文件描述符的监视范围是？</li><li>如何设定select函数的超时时间？</li></ul><p>第一件事：文件描述符的监视范围与select函数的第一个参数有关，select函数要求通过第一个参数传递监视对象文件描述符的数量。</p><p>第二件事：select函数超时时间与select函数的最后一个参数有关，其中timeval的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec;<span class="comment">//seconds</span></span><br><span class="line">    <span class="type">long</span> tv_usec;<span class="comment">//microseconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来select函数只有在监视的文件描述符发生变化时才返回，如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。如果不想设置超时时间，则传递NULL参数。</p><h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><ol><li>将当前进程的所有文件描述符，一次性的从用户态拷贝到内核态</li><li>在内核中快速的无差别遍历每个fd，判断是否有数据达到</li><li>将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd的个数</li><li>在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>文件描述符为bitmap结构，有长度1024的结构</li><li>fdset无法做到重用，每次循环必须重新创建</li><li>频繁的用户态和内核态拷贝，性能开销较大</li><li>需要对文件描述符表进行遍历，O(n)的轮询时间复杂度</li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">//fds用来存放文件描述符</span></span><br><span class="line"><span class="comment">//nfds用来制定文件描述符个数</span></span><br><span class="line"><span class="comment">//timeout超时等待的时间</span></span><br></pre></td></tr></table></figure><p>poll使用链表结构来保存文件描述符，这样就没有了1024个文件描述符的限制了</p><p>select存在的部分缺点在poll当中仍然存在，性能上没有得到太大的提升。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是在Linux内核2.6版本中提出的，是select和poll的增强版本。与select和epoll相比，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> IO多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何深入理解虚函数和多态</title>
      <link href="/archives/edf5f749.html"/>
      <url>/archives/edf5f749.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何深入理解虚函数和多态？"><a href="#如何深入理解虚函数和多态？" class="headerlink" title="如何深入理解虚函数和多态？"></a>如何深入理解虚函数和多态？</h1><p>在我们深入学习C++的过程中，虚函数和多态是我们需要一直关注的要点，这两个要点能够检验我们是否深入了解C++。今天，我们就站在编译器的角度，探讨虚函数表和多态这两个话题。  </p><p>首先，我们看第一个问题，虚函数表和虚函数表指针的概念是什么？。我们先创建一个空类A，再创建一个A类对象a，接着计算一下对象a的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>大家可以自行测试，测试结果是对象a的sizeof值是1。所以，对于一个空类对象，我们不能认为它的大小为0，只要它占用内存空间，sizeof值至少为1。因为一个空类对象在内存中至少要把位置该占住了，所以大小至少为1。</p><p>下面，我们往类A中添加两个函数func1()和func2()，这时在来计算对象a的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>计算结果仍然是1。这说明，类A中的普通函数不占用类对象的内存空间。</p><p>这时，我们往类A中再添加一个虚函数，这时再执行程序，计算sizeof(a)的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>我们发现计算结果由1变成了4，就是因为虚函数的加入引起了这样的变化。</p><p>当一个或多个函数加入到类中后，编译器会向类中插入一个看不见的成员变量，这种看不见的成员变量叫做虚函数表指针。在类中如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *vptr; <span class="comment">//虚函数表指针(virtual table pointer)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个虚函数表指针就是4个字节，而这4个字节就是占用类对象的内存空间的。</p><p>下面，第二个问题，我们说一说虚函数表的生成时机和生成原因。在类A中至少存在1个或多个虚函数时，在编译期间，编译器会为类A生成一个虚函数表(virtual table)，简称vbtl。这个虚函数表会一直伴随类A，在经过编译、链接，这个类A和伴随类A的虚函数表会都会保存到可执行文件中，在可执行文件执行过程中，也会加载到内存中。</p><p>接着，第三个问题，我们来讲虚函数表指针被赋值的时机以及虚函数表和虚函数表指针之间的关系。</p><p>对于这种有虚函数的类A，在编译期间，编译器会向类A的构造函数中安插为vptr赋值的语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">    vptr = &amp;A::vftable;     <span class="comment">//编译器在编译期间做的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序运行起来之后，当创建一个类A对象的时候，会执行类A的构造函数，因为构造函数中有为vptr赋值的语句，从而使vptr指向类A中的vbtl。</p><p>下面，我们来看第四个问题，类对象在内存中的布局。为了说明问题，我们在往类A中添加一些成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//12</span></span><br></pre></td></tr></table></figure><p>内存分布如下图所示，因为普通成员函数不占用类对象的内存空间，所以对选哪个a的大小是12个字节。<br><img src="https://s1.imagehub.cc/images/2023/09/15/image48973d951f9436a5.png" alt="内存布局"></p><p>最后，我们讲一下第五个问题，虚函数的工作原理以及多态性的体现。常规的多态性的理解，父类中有一个虚函数，子类中也有一个同名的虚函数，当通过父类指针new一个子类对象时，或者通过父类引用来绑定一个子类对象的时候，如果用这个父类指针来调用这个虚函数，那么调用其实是子类的虚函数。多态性往深入来说，可以从代码实现上和表现形式上来说，但又有一点是相同的，那就是<strong>多态必须存在虚函数，没有虚函数，绝不可能存在多态</strong>。类中定义了虚函数，并且我们要调用这个虚函数，那才存在多态性的可能。</p><p>从代码实现上来看一看多态性的体现。当调用虚函数的时候，我们可以看一看调用路线，看是不是利用vptr找到vtbl，然后通过查询vtbl扎到虚函数表的入口并执行。如果调用虚函数走的是这个路线，那就是多态。</p><p>看下面的代码中函数调用是不是多态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Base* pa = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">pa-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//这是不是多态，是多态的</span></span><br><span class="line"></span><br><span class="line">Base base;</span><br><span class="line">base.<span class="built_in">myvirfunc</span>(); <span class="comment">//这个就不是多态</span></span><br><span class="line"></span><br><span class="line">Base &amp;ybase = &amp;base;</span><br><span class="line">&amp;ybase-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//这个也是多态</span></span><br></pre></td></tr></table></figure><p>可以通过汇编代码来看虚函数时如何具体调用的了。</p><p>从表现形式上看多态性的具体体现。在写代码时需遵循以下几点：</p><ol><li>程序中即存在父类也存在子类，父类中必须含有虚函数，子类中也必须重写父类中的虚函数。</li><li>父类指针指向子类对象，或者父类引用绑定（指向）子类对象。</li><li>当通过父类的指针或引用，调用子类中重写的虚函数时，就能看出多态性的表现了。<br>示例代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类指针指向子类对象</span></span><br><span class="line">Derive derive;</span><br><span class="line">Base* pbase = &amp;derive;</span><br><span class="line">pbase-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//Derive::myvirfunc()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Base* pbase2 = <span class="keyword">new</span> <span class="built_in">Derive</span>(); <span class="comment">//释放内存请自行释放，在这里没演示</span></span><br><span class="line">pbase2-&gt;<span class="built_in">myvirfunc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类引用绑定（指向）子类对象</span></span><br><span class="line">Derive derive2;</span><br><span class="line">Base&amp; yinbase = derive2;</span><br><span class="line">yinbase.<span class="built_in">myvirfunc</span>(); <span class="comment">//Derive::myvirfunc()</span></span><br></pre></td></tr></table></figure>假设父类有虚函数f、g、h，子类重写了虚函数g，那么它们的内存布局如下所示：<br><img src="https://s1.imagehub.cc/images/2023/09/15/image37b41932e586f34b.png"></li></ol><p>至此就是文章的全部内容，感谢您的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/archives/4a17b156.html"/>
      <url>/archives/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
