<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>如何深入理解虚函数和多态.md</title>
      <link href="/2023/09/15/C++/%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/"/>
      <url>/2023/09/15/C++/%E5%A6%82%E4%BD%95%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h1 id="如何深入理解虚函数和多态？"><a href="#如何深入理解虚函数和多态？" class="headerlink" title="如何深入理解虚函数和多态？"></a>如何深入理解虚函数和多态？</h1><p>在我们深入学习C++的过程中，虚函数和多态是我们需要一直关注的要点，这两个要点能够检验我们是否深入了解C++。今天，我们就站在编译器的角度，探讨虚函数表和多态这两个话题。  </p><p>首先，我们看第一个问题，虚函数表和虚函数表指针的概念是什么？。我们先创建一个空类A，再创建一个A类对象a，接着计算一下对象a的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>大家可以自行测试，测试结果是对象a的sizeof值是1。所以，对于一个空类对象，我们不能认为它的大小为0，只要它占用内存空间，sizeof值至少为1。因为一个空类对象在内存中至少要把位置该占住了，所以大小至少为1。</p><p>下面，我们往类A中添加两个函数func1()和func2()，这时在来计算对象a的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>计算结果仍然是1。这说明，类A中的普通函数不占用类对象的内存空间。</p><p>这时，我们往类A中再添加一个虚函数，这时再执行程序，计算sizeof(a)的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>我们发现计算结果由1变成了4，就是因为虚函数的加入引起了这样的变化。</p><p>当一个或多个函数加入到类中后，编译器会向类中插入一个看不见的成员变量，这种看不见的成员变量叫做虚函数表指针。在类中如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *vptr; <span class="comment">//虚函数表指针(virtual table pointer)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个虚函数表指针就是4个字节，而这4个字节就是占用类对象的内存空间的。</p><p>下面，第二个问题，我们说一说虚函数表的生成时机和生成原因。在类A中至少存在1个或多个虚函数时，在编译期间，编译器会为类A生成一个虚函数表(virtual table)，简称vbtl。这个虚函数表会一直伴随类A，在经过编译、链接，这个类A和伴随类A的虚函数表会都会保存到可执行文件中，在可执行文件执行过程中，也会加载到内存中。</p><p>接着，第三个问题，我们来讲虚函数表指针被赋值的时机以及虚函数表和虚函数表指针之间的关系。</p><p>对于这种有虚函数的类A，在编译期间，编译器会向类A的构造函数中安插为vptr赋值的语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">    vptr = &amp;A::vftable;     <span class="comment">//编译器在编译期间做的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序运行起来之后，当创建一个类A对象的时候，会执行类A的构造函数，因为构造函数中有为vptr赋值的语句，从而使vptr指向类A中的vbtl。</p><p>下面，我们来看第四个问题，类对象在内存中的布局。为了说明问题，我们在往类A中添加一些成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//12</span></span><br></pre></td></tr></table></figure><p>内存分布如下图所示，因为普通成员函数不占用类对象的内存空间，所以对选哪个a的大小是12个字节。<br><img src="https://s1.imagehub.cc/images/2023/09/15/image48973d951f9436a5.png" alt="内存布局"></p><p>最后，我们讲一下第五个问题，虚函数的工作原理以及多态性的体现。常规的多态性的理解，父类中有一个虚函数，子类中也有一个同名的虚函数，当通过父类指针new一个子类对象时，或者通过父类引用来绑定一个子类对象的时候，如果用这个父类指针来调用这个虚函数，那么调用其实是子类的虚函数。多态性往深入来说，可以从代码实现上和表现形式上来说，但又有一点是相同的，那就是<strong>多态必须存在虚函数，没有虚函数，绝不可能存在多态</strong>。类中定义了虚函数，并且我们要调用这个虚函数，那才存在多态性的可能。</p><p>从代码实现上来看一看多态性的体现。当调用虚函数的时候，我们可以看一看调用路线，看是不是利用vptr找到vtbl，然后通过查询vtbl扎到虚函数表的入口并执行。如果调用虚函数走的是这个路线，那就是多态。</p><p>看下面的代码中函数调用是不是多态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Base* pa = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">pa-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//这是不是多态，是多态的</span></span><br><span class="line"></span><br><span class="line">Base base;</span><br><span class="line">base.<span class="built_in">myvirfunc</span>(); <span class="comment">//这个就不是多态</span></span><br><span class="line"></span><br><span class="line">Base &amp;ybase = &amp;base;</span><br><span class="line">&amp;ybase-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//这个也是多态</span></span><br></pre></td></tr></table></figure><p>可以通过汇编代码来看虚函数时如何具体调用的了。</p><p>从表现形式上看多态性的具体体现。在写代码时需遵循以下几点：</p><ol><li>程序中即存在父类也存在子类，父类中必须含有虚函数，子类中也必须重写父类中的虚函数。</li><li>父类指针指向子类对象，或者父类引用绑定（指向）子类对象。</li><li>当通过父类的指针或引用，调用子类中重写的虚函数时，就能看出多态性的表现了。<br>示例代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类指针指向子类对象</span></span><br><span class="line">Derive derive;</span><br><span class="line">Base* pbase = &amp;derive;</span><br><span class="line">pbase-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//Derive::myvirfunc()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Base* pbase2 = <span class="keyword">new</span> <span class="built_in">Derive</span>(); <span class="comment">//释放内存请自行释放，在这里没演示</span></span><br><span class="line">pbase2-&gt;<span class="built_in">myvirfunc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类引用绑定（指向）子类对象</span></span><br><span class="line">Derive derive2;</span><br><span class="line">Base&amp; yinbase = derive2;</span><br><span class="line">yinbase.<span class="built_in">myvirfunc</span>(); <span class="comment">//Derive::myvirfunc()</span></span><br></pre></td></tr></table></figure>假设父类有虚函数f、g、h，子类重写了虚函数g，那么它们的内存布局如下所示：<br><img src="https://s1.imagehub.cc/images/2023/09/15/image37b41932e586f34b.png"></li></ol><p>至此就是文章的全部内容，感谢您的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码块演示</title>
      <link href="/2023/09/05/C++/cpp/"/>
      <url>/2023/09/05/C++/cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="01-程序的运行过程：从代码到机器运行"><a href="#01-程序的运行过程：从代码到机器运行" class="headerlink" title="01 | 程序的运行过程：从代码到机器运行"></a>01 | 程序的运行过程：从代码到机器运行</h1><p>你好，我是LMOS。<br><img src="https://picsum.photos/750/400" alt="图片名称描述开启"><br>欢迎来到操作系统第一课。在真正打造操作系统前，有一条必经之路：你知道程序是如何运行的吗？</p><p>一个熟练的编程老手只需肉眼看着代码，就能对其运行的过程了如指掌。但对于初学者来说，这常常是很困难的事，这需要好几年的程序开发经验，和在长期的程序开发过程中对编程基本功的积累。</p><p>我记得自己最初学习操作系统的时候，面对逻辑稍微复杂的一些程序，在编写、调试代码时，就会陷入代码的迷宫，找不到东南西北。</p><p>不知道你现在处在什么阶段，是否曾有同样的感受？ <strong>我常常说，扎实的基本功就像手里的指南针，你可以一步步强大到不依赖它，但是不能没有。</strong></p><p>因此今天，我将带领你从“Hello World”起，扎实基本功，探索程序如何运行的所有细节和原理。这节课的配套代码，你可以从 <a href="https://gitee.com/lmos/cosmos/tree/master/lesson01/HelloWorld">这里</a> 下载。</p><h2 id="一切要从牛人做的牛逼事说起"><a href="#一切要从牛人做的牛逼事说起" class="headerlink" title="一切要从牛人做的牛逼事说起"></a>一切要从牛人做的牛逼事说起</h2><p><strong>第一位牛人，是世界级计算机大佬的传奇——Unix之父Ken Thompson</strong>。</p><p>在上世纪60年代的一个夏天，Ken Thompson的妻子要回娘家一个月。呆在贝尔实验室的他，竟然利用这极为孤独的一个月，开发出了UNiplexed Information and Computing System（UNICS）——即UNIX的雏形，一个全新的操作系统。</p><p>要知道，在当时C语言并没有诞生，从严格意义上说，他是用B语言和汇编语言在PDP-7的机器上完成的。</p><p><img src="/images/369457/418b94aed8aab2abf6538a103d9f2856.png"></p><p><strong>牛人的朋友也是牛人，他的朋友Dennis Ritchie也随之加入其中，共同创造了大名鼎鼎的C语言，并用C语言写出了UNIX和后来的类UNIX体系的几十种操作系统，也写出了对后世影响深远的第一版“Hello World”</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Hello World!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>计算机硬件是无法直接运行这个C语言文本程序代码的，需要C语言编译器，把这个代码编译成具体硬件平台的二进制代码。再由具体操作系统建立进程，把这个二进制文件装进其进程的内存空间中，才能运行。</p><p>听起来很复杂？别急，接着往下看。</p><h2 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h2><p>我们暂且不急着摸清操作系统所做的工作，先来研究一下编译过程和硬件执行程序的过程，约定使用GCC相关的工具链。</p><p>那么使用命令：gcc HelloWorld.c -o HelloWorld 或者 gcc .&#x2F;HelloWorld.c -o .&#x2F;HelloWorld ，就可以编译这段代码。其实，GCC只是完成编译工作的驱动程序，它会根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作。</p><p>下图就是编译这段代码的过程：</p><p><img src="/images/369457/f2b10135ed52436888a793327e4d5a4a.jpg"></p><p>其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：</p><ul><li>gcc HelloWorld.c -E -o HelloWorld.i预处理：加入头文件，替换宏。</li><li>gcc HelloWorld.c -S -c -o HelloWorld.s编译：包含预处理，将C程序转换成汇编程序。</li><li>gcc HelloWorld.c -c -o HelloWorld.o汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。</li><li>gcc HelloWorld.c -o HelloWorld链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。</li></ul><h2 id="程序装载执行"><a href="#程序装载执行" class="headerlink" title="程序装载执行"></a>程序装载执行</h2><p>对运行内容有了了解后，我们开始程序的装载执行。</p><p>我们将请出 <strong>第三位牛人——大名鼎鼎的阿兰·图灵。在他的众多贡献中，很重要的一个就是提出了一种理想中的机器：图灵机。</strong></p><p>图灵机是一个抽象的模型，它是这样的：有一条无限长的纸带，纸带上有无限个小格子，小格子中写有相关的信息，纸带上有一个读头，读头能根据纸带小格子里的信息做相关的操作并能来回移动。</p><p>文字叙述还不够形象，我们来画一幅插图：</p><p><img src="/images/369457/6914497643dbb0aaefffc32b865dcf7d.png"></p><p>不理解？下面我再带你用图灵机执行一下“1+1&#x3D;2”的计算，你就明白了。我们定义读头读到“+”之后，就依次移动读头两次并读取格子中的数据，最后读头计算把结果写入第二个数据的下一个格子里，整个过程如下图：</p><p><img src="/images/369457/43812abfe104d6885815825f07622e87.jpg"></p><p>这个理想的模型是好，但是理想终归是理想，想要成为现实，我们得想其它办法。</p><p><strong>于是，第四位牛人来了，他提出了电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行，他叫冯诺依曼，他的电子计算机理论叫冯诺依曼体系结构。</strong></p><p>根据冯诺依曼体系结构构成的计算机，必须具有如下功能：</p><ul><li>把程序和数据装入到计算机中；</li><li>必须具有长期记住程序、数据的中间结果及最终运算结果；</li><li>完成各种算术、逻辑运算和数据传送等数据加工处理；</li><li>根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；</li><li>能够按照要求将处理的数据结果显示给用户。</li></ul><p>为了完成上述的功能，计算机必须具备五大基本组成部件：</p><ul><li>装载数据和程序的输入设备；</li><li>记住程序和数据的存储器；</li><li>完成数据加工处理的运算器；</li><li>控制程序执行的控制器；</li><li>显示处理结果的输出设备。</li></ul><p>根据冯诺依曼的理论，我们只要把图灵机的几个部件换成电子设备，就可以变成一个最小核心的电子计算机，如下图：</p><p><img src="/images/369457/bde34df011c397yy42dc00fe6bd35226.jpg"></p><p>是不是非常简单？这次我们发现读头不再来回移动了，而是靠地址总线寻找对应的“纸带格子”。读取写入数据由数据总线完成，而动作的控制就是控制总线的职责了。</p><h2 id="更形象地将HelloWorld程序装入原型计算机"><a href="#更形象地将HelloWorld程序装入原型计算机" class="headerlink" title="更形象地将HelloWorld程序装入原型计算机"></a>更形象地将HelloWorld程序装入原型计算机</h2><p>下面，我们尝试将HelloWorld程序装入这个原型计算机，在装入之前，我们先要搞清楚HelloWorld程序中有什么。</p><p>我们可以通过gcc -c -S HelloWorld得到（只能得到其汇编代码，而不能得到二进制数据）。我们用objdump -d HelloWorld程序，得到&#x2F;lesson01&#x2F;HelloWorld.dump，其中有很多库代码（只需关注main函数相关的代码），如下图：</p><p><img src="/images/369457/3991a042107b90612122b14596c65614.jpeg"></p><p>以上图中，分成四列：第一列为地址；第二列为十六进制，表示真正装入机器中的代码数据；第三列是对应的汇编代码；第四列是相关代码的注释。这是x86_64体系的代码，由此可以看出x86 CPU是变长指令集。</p><p>接下来，我们把这段代码数据装入最小电子计算机，状态如下图：</p><p><img src="/images/369457/5d4889e7bf20e670ee71cc9b6285c96e.jpg"></p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>以上，对应图中的伪代码你应该明白了：现代电子计算机正是通过内存中的信息（指令和数据）做出相应的操作，并通过内存地址的变化，达到程序读取数据，控制程序流程（顺序、跳转对应该图灵机的读头来回移动）的功能。</p><p>这和图灵机的核心思想相比，没有根本性的变化。只要配合一些I&#x2F;O设备，让用户输入并显示计算结果给用户，就是一台现代意义的电子计算机。</p><p>到这里，我们理清了程序运行的所有细节和原理。还有一点，你可能有点疑惑，即printf对应的puts函数，到底做了什么？而这正是我们后面的课程要探索的！</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>为了实现C语言中函数的调用和返回功能，CPU实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call和ret指令在逻辑上执行的操作是怎样的呢？</p><p>期待你在留言区跟我交流互动。如果这节课对你有所启发，也欢迎转发给你的朋友、同事，跟他们一起学习进步。</p><p>这是一段C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//Linux -lpthread</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> is_exit = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;begin sub thread main &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!is_exit) <span class="keyword">break</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;in thread &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));<span class="comment">//1000ms</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;end sub thread main &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//thread th(ThreadMain); //出错，thread对象被销毁 子线程还在运行</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">th</span><span class="params">(ThreadMain)</span></span>;</span><br><span class="line">th.<span class="built_in">detach</span>(); <span class="comment">//子线程与主线程分离 守护线程</span></span><br><span class="line"><span class="comment">//坑 ：主线程退出后 子线程不一定退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">th</span><span class="params">(ThreadMain)</span></span>;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));<span class="comment">//1000ms</span></span><br><span class="line">is_exit = <span class="literal">true</span>; <span class="comment">//通知子线程退出</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程阻塞，等待子线程退出&quot;</span> &lt;&lt; endl;</span><br><span class="line">th.<span class="built_in">join</span>(); <span class="comment">//主线程阻塞，等待子线程退出</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子线程已经退出！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boke </tag>
            
            <tag> code </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/04/hello-world/"/>
      <url>/2023/09/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
