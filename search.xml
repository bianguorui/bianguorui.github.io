<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>《数据结构与算法之美》入门篇读书笔记</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h3 id="03-复杂度分析（上）"><a href="#03-复杂度分析（上）" class="headerlink" title="03 复杂度分析（上）"></a>03 复杂度分析（上）</h3><p>我们常用的时间复杂度表示法为<strong>大O时间复杂度表示法</strong>，大O时间复杂度表示法并不具体表示代码的真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以也叫<strong>渐进时间复杂度</strong>，简称<strong>时间复杂度</strong>。</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><h5 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1.只关注循环执行次数最多的一段代码"></a>1.只关注循环执行次数最多的一段代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如这段代码，第4、5行就是循环执行次数最多的代码，总共执行了n次，总的时间复杂度为O(n)。</p><h5 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2.加法法则：总复杂度等于量级最大的那段代码的复杂度"></a>2.加法法则：总复杂度等于量级最大的那段代码的复杂度</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> p = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; p &lt; <span class="number">100</span>; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> q = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="type">int</span> sum_3 = <span class="number">0</span>;</span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = <span class="number">1</span>; </span><br><span class="line">     <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="keyword">return</span> sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>第一段代码sum_1执行了100次，这是一个常量时间的执行时间，对于n的不断增长，我们可以忽略不计这一段的执行时间。</p><p>而第二段和第三段的时间复杂度是O(n)和O(n^2)。<strong>总的时间复杂度等于量级最大的那段代码的时间复杂度</strong>。抽象规律就是：</p><p>如果 T1(n)&#x3D;O(f(n))，T2(n)&#x3D;O(g(n))；那么 T(n)&#x3D;T1(n)+T2(n)&#x3D;max(O(f(n)), O(g(n))) &#x3D;O(max(f(n), g(n))).</p><h5 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a>3.乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">   <span class="type">int</span> ret = <span class="number">0</span>; </span><br><span class="line">   <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">   <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + <span class="built_in">f</span>(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>cal() 函数里面嵌套了 f() 函数，f() 函数的时间复杂度是O(n)，cal() 函数也是O(n)的，所以嵌套出来的结果是O(n^2)。</p><h4 id="几种常见的时间复杂度实例分析"><a href="#几种常见的时间复杂度实例分析" class="headerlink" title="几种常见的时间复杂度实例分析"></a>几种常见的时间复杂度实例分析</h4><p><img src="https://img-blog.csdnimg.cn/e44b2705eec14887ae87c01a504ff56b.png" alt="在这里插入图片描述"></p><h5 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h5><p>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><h5 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= n)  &#123;</span><br><span class="line">  i = i * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据前面所讲，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>变量 i 实际上是按一个等比数列来变化的。通过$$2^x&#x3D;n$$求解 x 这个问题我们想高中应该就学过了，我就不多说了。x&#x3D;log2n，所以，这段代码的时间复杂度就是 O(log2n)。</p><p>另外：在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><h5 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h5><p>这种情况下的时间复杂度由<strong>两个数据的规模</strong>来决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">cal</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> j = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们无法事先知道哪一个数据规模大，所以我们就不能省略掉其中一个。所以，上述代码的时间复杂度是O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) &#x3D; O(f(m) + g(n))。但是乘法法则继续有效：T1(m)*T2(n) &#x3D; O(f(m) * f(n))。</p><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><p><strong>渐进空间复杂度，表示算法的存储空间与数据规模之间的增长关系。</strong></p><h4 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h4><p><img src="https://img-blog.csdnimg.cn/b6c28d02ce4d4a4eafe6b21e070cbae6.png" alt="在这里插入图片描述"></p><h3 id="04-复杂度分析-下"><a href="#04-复杂度分析-下" class="headerlink" title="04 复杂度分析(下)"></a>04 复杂度分析(下)</h3><h4 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h4><p>顾名思义，<strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</strong>。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><p>同理，<strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</strong>。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p><h4 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a>平均情况时间复杂度</h4><p>平均情况下的时间复杂度</p><h4 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h4><p>均摊时间复杂度，听起来跟平均时间复杂度有点儿像。对于初学者来说，这两个概念确实非常容易弄混。我前面说了，大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux下IO模式和IO多路复用详解</title>
      <link href="/archives/0.html"/>
      <url>/archives/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux下IO模式和IO多路复用详解"><a href="#Linux下IO模式和IO多路复用详解" class="headerlink" title="Linux下IO模式和IO多路复用详解"></a>Linux下IO模式和IO多路复用详解</h1><p>今天我们来谈一谈Linux系统中的IO模式和IO多路复用。</p><h2 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h2><p>首先，我们要知道对于一次IO操作，操作系统需要干什么？</p><p>在Linux的缓存IO机制中，操作系统会将IO的数据缓存在文件系统的页缓存中，即数据会先拷贝到操作系统内核的缓冲区中，然后才将操作系统内核的数据缓冲区拷贝到应用程序的地址空间。当然，这种机制也有<strong>缺点</strong> ：数据在传输过程中需要在应用程序地址空间和内核进行多次的数据拷贝操作，这对于CPU和内存的开销是非常大的。</p><p>一次典型的网络IO调用分为两个阶段，分别是“数据就绪”和“数据读写”。数据就绪阶段分为<strong>阻塞</strong>和<strong>非阻塞</strong>，表现结果就是，阻塞当前线程或是直接返回。数据读写阶段分为<strong>同步</strong>和<strong>异步</strong>。</p><p>其中，同步表示A向B请求调用一个网路IO接口时，数据读写部分都是由A自己一个人完成的（不管是阻塞和非阻塞）；异步表示A向B请求调用一个网络IO接口时，向B传入请求的事件以及事件发生时通知的方式，A就可以去处理其他逻辑了，当B监听到事件处理完成后，会用事先约定好的通知方式，<strong>通知</strong>A处理结果。在异步处理逻辑中，一定要关注通知二字，这是区分是同步和异步的重要的一点。</p><p>因此，Linux系统中产生了下面5种网络模式：</p><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO</li><li>异步IO</li></ul><h3 id="阻塞IO（blocking-IO）"><a href="#阻塞IO（blocking-IO）" class="headerlink" title="阻塞IO（blocking IO）"></a>阻塞IO（blocking IO）</h3><p><img src="https://z1.ax1x.com/2023/10/10/pPzlRdH.png" alt="阻塞IO"></p><p>在Linux中，默认情况下所有socket都是阻塞的。当调用read系统调用时，kernel就开始了第一阶段：数据准备。kernel就会等待数据的到来，也就是数据被拷贝到操作内核是需要一个过程的，而在用户进程这边，整个进程会被阻塞（进程自己选择的结果）。当kernel等到数据准备好了，就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程解除阻塞状态，重新运行起来。</p><h3 id="非阻塞IO（nonblocking-IO）"><a href="#非阻塞IO（nonblocking-IO）" class="headerlink" title="非阻塞IO（nonblocking IO）"></a>非阻塞IO（nonblocking IO）</h3><p><img src="https://z1.ax1x.com/2023/10/10/pPztT4e.png" alt="非阻塞IO"></p><p>在Linux中，socket可以设置为非阻塞IO模式。非阻塞IO模式下的流程如上所示。</p><p>当应用进程进行read操作时，如果kernel中的数据没准备好，它并不是阻塞应用进程，而是立刻返回EAGAIN错误代码（在read操作时，表示取文件&#x2F;设备时资源临时不可用,需要重试读取操作）。从应用进程的角度来看，应用进程发起一个read操作后，并不需要等待，而是马上得到了一个结果。应用进程判断结果是一个error时，它就知道kernel还没准备好数据，于是再次发起read操作。一旦kernel中的数据准备好了，并再次收到了应用进程的read系统调用，就会马上将数据从内核空间拷贝到用户空间，然后返回，应用处理数据。</p><p>所以说，非阻塞IO的特点是用户进程不断地<strong>轮询</strong>kernel，数据准备好了没有。</p><h3 id="IO多路复用（-IO-multiplexing）"><a href="#IO多路复用（-IO-multiplexing）" class="headerlink" title="IO多路复用（ IO multiplexing）"></a>IO多路复用（ IO multiplexing）</h3><p><img src="https://z1.ax1x.com/2023/10/10/pPzN6Vf.md.png" alt="IO多路复用"></p><p>IO多路复用就是我们常说<strong>select</strong>、<strong>poll</strong>、<strong>epoll</strong>，这里我们先提前说一下，这三种IO多路复用接口都是<strong>同步IO</strong>，请谨记。</p><p>select&#x2F;epoll的好处是单个process就可以同时处理多个网络连接的IO。IO多路复用的基本原理就是select、poll、epoll这些接口会不断地轮询所有的socket，当某个socket有数据到达了，就告诉用户进程。当应用进程调用了select，那整个进程都会被阻塞，与此同时，kernel会“监视”所有select负责的socket，当其中的任何一个socket的数据准备好了，select就会返回。应用进程就接着调用read操作，将数据从kernel拷贝到应用进程。</p><h3 id="信号驱动IO（signal-driven）"><a href="#信号驱动IO（signal-driven）" class="headerlink" title="信号驱动IO（signal-driven）"></a>信号驱动IO（signal-driven）</h3><p><img src="https://z1.ax1x.com/2023/10/11/pPzUJQs.md.png" alt="信号驱动"></p><p>内核在第一个阶段是异步，在第二个阶段是同步。与非阻塞IO的区别在于它提供了消息通知机制，不需要应用进程来不断地轮询检查，减少了系统API的调用次数，提高了效率。</p><h3 id="异步IO（asynchronous）"><a href="#异步IO（asynchronous）" class="headerlink" title="异步IO（asynchronous）"></a>异步IO（asynchronous）</h3><p><img src="https://z1.ax1x.com/2023/10/11/pPzUBYF.md.png" alt="异步IO"></p><p>应用进程发起read操作后，就去做其他事情了，然后就等待将kerne发送信号l通知应用进程数据准备好了就行，告诉应用进程可以进行read操作。</p><h2 id="IO多路复用之select、poll、epoll详解"><a href="#IO多路复用之select、poll、epoll详解" class="headerlink" title="IO多路复用之select、poll、epoll详解"></a>IO多路复用之select、poll、epoll详解</h2><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>下面我们来看select函数的功能和调用顺序。</p><p>使用select函数时可以将多个文件描述符集中到一起统一监视。select函数的调用方法和顺序如下所示：</p><p><img src="https://z1.ax1x.com/2023/10/11/pPzXH0J.png" alt="select函数调用过程"></p><p>由图可以看出，在调用select函数之前需要一些准备工作，调查后还需要查看结果，下面我们根据调用顺序逐一进行讲解。</p><h4 id="设置文件描述符"><a href="#设置文件描述符" class="headerlink" title="设置文件描述符"></a>设置文件描述符</h4><p>fd_set数组变量就是用来将要监视的文件描述符集中到一起的变量，该数组是存有0和1的<strong>位数组</strong>。</p><p><img src="https://z1.ax1x.com/2023/10/11/pPzjHv8.png"></p><p>最左端的位表示文件描述符0，如果该位设置为1，则表示该文件描述符是监视对象。由图中很明显看出文件描述符1和3是监视对象。</p><blockquote><p><strong>注意</strong> ：针对fd_set变量的操作都是以位为单位进行操作的，所以不能直接将文件描述符的数字注册到fd_set变量中。</p></blockquote><p>实际上，在fd_set变量的注册中或更改值都是通过下列宏进行完成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FD_ZERO(fd_set* fdset): 将fd_set变量的所有位初始化为0</span><br><span class="line">FD_SET(int fd, fd_set* fdset): 在参数fdset指向的变量中注册文件描述符fd的信息</span><br><span class="line">FD_CLR(int fd, fd_set* fdset): 从参数fdset指向的变量中清除文件描述符fd1的信息</span><br><span class="line">FD_ISSET(int fd, fd_set* fdset): 若参数fdset指向的变量中包含文件描述符fd的信息，则返回“真”</span><br></pre></td></tr></table></figure><p>上述函数中，FD_ISSET函数用来验证select函数的调用结果。</p><h4 id="设置检查（监视）范围及超时"><a href="#设置检查（监视）范围及超时" class="headerlink" title="设置检查（监视）范围及超时"></a>设置检查（监视）范围及超时</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, <span class="type">const</span> <span class="keyword">struct</span> timeval* timeout)</span>;</span><br><span class="line"><span class="comment">//成功时返回大于0的值，失败时返回-1</span></span><br><span class="line"><span class="comment">//各参数解释：</span></span><br><span class="line"><span class="comment">//maxfd:监视对象文件描述符数量</span></span><br><span class="line"><span class="comment">//readset: 将所有关注“是否存在待读取数据”文件描述符注册到fd_set变量，并传递其地址值</span></span><br><span class="line"><span class="comment">//writeset: 将所有关注“是否可传输无阻塞数据”文件描述符注册到fd_set变量，并传递其地址值</span></span><br><span class="line"><span class="comment">//exceptset: 将所有关注“是否发生异常”文件描述符注册到fd_set变量，并传递其地址值</span></span><br><span class="line"><span class="comment">//timeout: 调用select函数后，为防止陷入无限阻塞的状态，传递超时（time-out）信息</span></span><br><span class="line"><span class="comment">//返回值：发生错误时返回-1，超时返回0.因发生关注的事件返回时，返回大于0的值，该值是发生事件的文件描述符数。</span></span><br></pre></td></tr></table></figure><p>在调用select函数前，需要决定下面2件事</p><ul><li>文件描述符的监视范围是？</li><li>如何设定select函数的超时时间？</li></ul><p>第一件事：文件描述符的监视范围与select函数的第一个参数有关，select函数要求通过第一个参数传递监视对象文件描述符的数量。</p><p>第二件事：select函数超时时间与select函数的最后一个参数有关，其中timeval的结构体如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">long</span> tv_sec;<span class="comment">//seconds</span></span><br><span class="line">    <span class="type">long</span> tv_usec;<span class="comment">//microseconds</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本来select函数只有在监视的文件描述符发生变化时才返回，如果未发生变化，就会进入阻塞状态。指定超时时间就是为了防止这种情况的发生。如果不想设置超时时间，则传递NULL参数。</p><h4 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h4><ol><li>将当前进程的所有文件描述符，一次性的从用户态拷贝到内核态</li><li>在内核中快速的无差别遍历每个fd，判断是否有数据达到</li><li>将所有fd状态，从内核态拷贝到用户态，并返回已就绪fd的个数</li><li>在用户态遍历判断具体哪个fd已就绪，然后进行相应的事件处理。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>文件描述符为bitmap结构，有长度1024的结构</li><li>fdset无法做到重用，每次循环必须重新创建</li><li>频繁的用户态和内核态拷贝，性能开销较大</li><li>需要对文件描述符表进行遍历，O(n)的轮询时间复杂度</li></ol><h3 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">poll</span> <span class="params">(<span class="keyword">struct</span> pollfd *fds, <span class="type">unsigned</span> <span class="type">int</span> nfds, <span class="type">int</span> timeout)</span>;</span><br><span class="line"><span class="comment">//fds用来存放文件描述符</span></span><br><span class="line"><span class="comment">//nfds用来制定文件描述符个数</span></span><br><span class="line"><span class="comment">//timeout超时等待的时间</span></span><br></pre></td></tr></table></figure><p>poll使用链表结构来保存文件描述符，这样就没有了1024个文件描述符的限制了</p><p>select存在的部分缺点在poll当中仍然存在，性能上没有得到太大的提升。</p><h3 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h3><p>epoll是在Linux内核2.6版本中提出的，是select和poll的增强版本。与select和epoll相比，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的</p>]]></content>
      
      
      <categories>
          
          <category> 网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 网络编程 </tag>
            
            <tag> IO多路复用 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何深入理解虚函数和多态</title>
      <link href="/archives/edf5f749.html"/>
      <url>/archives/edf5f749.html</url>
      
        <content type="html"><![CDATA[<h1 id="如何深入理解虚函数和多态？"><a href="#如何深入理解虚函数和多态？" class="headerlink" title="如何深入理解虚函数和多态？"></a>如何深入理解虚函数和多态？</h1><p>在我们深入学习C++的过程中，虚函数和多态是我们需要一直关注的要点，这两个要点能够检验我们是否深入了解C++。今天，我们就站在编译器的角度，探讨虚函数表和多态这两个话题。  </p><p>首先，我们看第一个问题，虚函数表和虚函数表指针的概念是什么？。我们先创建一个空类A，再创建一个A类对象a，接着计算一下对象a的大小：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">A a;</span><br><span class="line">cout &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>大家可以自行测试，测试结果是对象a的sizeof值是1。所以，对于一个空类对象，我们不能认为它的大小为0，只要它占用内存空间，sizeof值至少为1。因为一个空类对象在内存中至少要把位置该占住了，所以大小至少为1。</p><p>下面，我们往类A中添加两个函数func1()和func2()，这时在来计算对象a的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>计算结果仍然是1。这说明，类A中的普通函数不占用类对象的内存空间。</p><p>这时，我们往类A中再添加一个虚函数，这时再执行程序，计算sizeof(a)的值：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//4</span></span><br></pre></td></tr></table></figure><p>我们发现计算结果由1变成了4，就是因为虚函数的加入引起了这样的变化。</p><p>当一个或多个函数加入到类中后，编译器会向类中插入一个看不见的成员变量，这种看不见的成员变量叫做虚函数表指针。在类中如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> *vptr; <span class="comment">//虚函数表指针(virtual table pointer)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个虚函数表指针就是4个字节，而这4个字节就是占用类对象的内存空间的。</p><p>下面，第二个问题，我们说一说虚函数表的生成时机和生成原因。在类A中至少存在1个或多个虚函数时，在编译期间，编译器会为类A生成一个虚函数表(virtual table)，简称vbtl。这个虚函数表会一直伴随类A，在经过编译、链接，这个类A和伴随类A的虚函数表会都会保存到可执行文件中，在可执行文件执行过程中，也会加载到内存中。</p><p>接着，第三个问题，我们来讲虚函数表指针被赋值的时机以及虚函数表和虚函数表指针之间的关系。</p><p>对于这种有虚函数的类A，在编译期间，编译器会向类A的构造函数中安插为vptr赋值的语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>() &#123;</span><br><span class="line">    vptr = &amp;A::vftable;     <span class="comment">//编译器在编译期间做的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序运行起来之后，当创建一个类A对象的时候，会执行类A的构造函数，因为构造函数中有为vptr赋值的语句，从而使vptr指向类A中的vbtl。</p><p>下面，我们来看第四个问题，类对象在内存中的布局。为了说明问题，我们在往类A中添加一些成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">vfunc1</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">A</span>()&#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> m_a;</span><br><span class="line">    <span class="type">int</span> m_b;</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;sizeof(a)=&quot;</span> &lt;&lt; <span class="built_in">sizeof</span>(a) &lt;&lt; endl; <span class="comment">//12</span></span><br></pre></td></tr></table></figure><p>内存分布如下图所示，因为普通成员函数不占用类对象的内存空间，所以对选哪个a的大小是12个字节。<br><img src="https://s1.imagehub.cc/images/2023/09/15/image48973d951f9436a5.png" alt="内存布局"></p><p>最后，我们讲一下第五个问题，虚函数的工作原理以及多态性的体现。常规的多态性的理解，父类中有一个虚函数，子类中也有一个同名的虚函数，当通过父类指针new一个子类对象时，或者通过父类引用来绑定一个子类对象的时候，如果用这个父类指针来调用这个虚函数，那么调用其实是子类的虚函数。多态性往深入来说，可以从代码实现上和表现形式上来说，但又有一点是相同的，那就是<strong>多态必须存在虚函数，没有虚函数，绝不可能存在多态</strong>。类中定义了虚函数，并且我们要调用这个虚函数，那才存在多态性的可能。</p><p>从代码实现上来看一看多态性的体现。当调用虚函数的时候，我们可以看一看调用路线，看是不是利用vptr找到vtbl，然后通过查询vtbl扎到虚函数表的入口并执行。如果调用虚函数走的是这个路线，那就是多态。</p><p>看下面的代码中函数调用是不是多态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Base* pa = <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">pa-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//这是不是多态，是多态的</span></span><br><span class="line"></span><br><span class="line">Base base;</span><br><span class="line">base.<span class="built_in">myvirfunc</span>(); <span class="comment">//这个就不是多态</span></span><br><span class="line"></span><br><span class="line">Base &amp;ybase = &amp;base;</span><br><span class="line">&amp;ybase-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//这个也是多态</span></span><br></pre></td></tr></table></figure><p>可以通过汇编代码来看虚函数时如何具体调用的了。</p><p>从表现形式上看多态性的具体体现。在写代码时需遵循以下几点：</p><ol><li>程序中即存在父类也存在子类，父类中必须含有虚函数，子类中也必须重写父类中的虚函数。</li><li>父类指针指向子类对象，或者父类引用绑定（指向）子类对象。</li><li>当通过父类的指针或引用，调用子类中重写的虚函数时，就能看出多态性的表现了。<br>示例代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Derive</span>:<span class="keyword">public</span> Base</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">myvirfunc</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//父类指针指向子类对象</span></span><br><span class="line">Derive derive;</span><br><span class="line">Base* pbase = &amp;derive;</span><br><span class="line">pbase-&gt;<span class="built_in">myvirfunc</span>(); <span class="comment">//Derive::myvirfunc()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Base* pbase2 = <span class="keyword">new</span> <span class="built_in">Derive</span>(); <span class="comment">//释放内存请自行释放，在这里没演示</span></span><br><span class="line">pbase2-&gt;<span class="built_in">myvirfunc</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">//父类引用绑定（指向）子类对象</span></span><br><span class="line">Derive derive2;</span><br><span class="line">Base&amp; yinbase = derive2;</span><br><span class="line">yinbase.<span class="built_in">myvirfunc</span>(); <span class="comment">//Derive::myvirfunc()</span></span><br></pre></td></tr></table></figure>假设父类有虚函数f、g、h，子类重写了虚函数g，那么它们的内存布局如下所示：<br><img src="https://s1.imagehub.cc/images/2023/09/15/image37b41932e586f34b.png"></li></ol><p>至此就是文章的全部内容，感谢您的阅读！</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++语法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/archives/4a17b156.html"/>
      <url>/archives/4a17b156.html</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
