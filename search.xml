<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>关于我</title>
      <link href="/2023/09/05/about/"/>
      <url>/2023/09/05/about/</url>
      
        <content type="html"><![CDATA[<h1 id="about"><a href="#about" class="headerlink" title="about"></a>about</h1><h2 id="fbgfdgabout"><a href="#fbgfdgabout" class="headerlink" title="fbgfdgabout"></a>fbgfdgabout</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码块演示222</title>
      <link href="/2023/09/05/codeshow/cpp2/"/>
      <url>/2023/09/05/codeshow/cpp2/</url>
      
        <content type="html"><![CDATA[<h1 id="02-几行汇编几行C：实现一个最简单的内核"><a href="#02-几行汇编几行C：实现一个最简单的内核" class="headerlink" title="02 | 几行汇编几行C：实现一个最简单的内核"></a>02 | 几行汇编几行C：实现一个最简单的内核</h1><p>你好，我是LMOS。</p><p>我们知道，在学习许多编程语言一开始的时候，都有一段用其语言编写的经典程序——Hello World。这不过是某一操作系统平台之上的应用程序，却心高气傲地问候世界。</p><p>而我们学习操作系统的时候，那么也不妨撇开其它现有的操作系统，基于硬件，写一个最小的操作系统——Hello OS，先练练手、热热身，直观感受一下。</p><p>本节课的配套代码，你可以从 <a href="https://gitee.com/lmos/cosmos/tree/master/lesson02/HelloOS">这里</a> 下载。</p><p>请注意，这节课主要是演示思路，不要求你马上动手实现。详细的环境安装、配置我们到第十节课再详细展开。有兴趣上手的同学，可以参考留言区置顶的实验笔记探索。</p><h2 id="PC机的引导流程"><a href="#PC机的引导流程" class="headerlink" title="PC机的引导流程"></a>PC机的引导流程</h2><p>看标题就知道，写操作系统要用汇编和C语言，尽管这个Hello OS很小，但也要用到两种编程语言。其实，现有的商业操作系统都是用这两种语言开发出来的。</p><p>先不用害怕，Hello OS的代码量很少。</p><p>其实，我们也不打算从PC的引导程序开始写起，原因是目前我们的知识储备还不够，所以先借用一下GRUB引导程序，只要我们的PC机上安装了Ubuntu Linux操作系统，GRUB就已经存在了。这会大大降低我们开始的难度，也不至于打消你的热情。</p><p><img src="/images/369502/1db2342da1abdc9f1f77e4c69a94d0dc.png"></p><p>那在写Hello OS之前，我们先要搞清楚Hello OS的引导流程，如下图所示：</p><p><img src="/images/369502/f2d31ab7144bf309761711efa9d6d4bd.jpg"></p><p>简单解释一下，PC机BIOS固件是固化在PC机主板上的ROM芯片中的，掉电也能保存，PC机上电后的第一条指令就是BIOS固件中的，它负责 <strong>检测和初始化CPU、内存及主板平台</strong>，然后加载引导设备（大概率是硬盘）中的第一个扇区数据，到0x7c00地址开始的内存空间，再接着跳转到0x7c00处执行指令，在我们这里的情况下就是GRUB引导程序。</p><p>当然，更先进的 <a href="https://www.uefi.org/">UEFI BIOS</a> 则不同，这里就不深入其中了，你可以通过链接自行了解。</p><h2 id="Hello-OS引导汇编代码"><a href="#Hello-OS引导汇编代码" class="headerlink" title="Hello OS引导汇编代码"></a>Hello OS引导汇编代码</h2><p>明白了PC机的启动流程，下面只剩下我们的Hello OS了，我们马上就去写好它。</p><p>我们先来写一段汇编代码。这里我要特别说明一个问题：为什么不能直接用C？</p><p><strong>C作为通用的高级语言，不能直接操作特定的硬件，而且C语言的函数调用、函数传参，都需要用栈。</strong></p><p>栈简单来说就是一块内存空间，其中数据满足 <strong>后进先出</strong> 的特性，它由CPU特定的栈寄存器指向，所以我们要先用汇编代码处理好这些C语言的工作环境。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">;彭东 @ 2021.01.09</span><br><span class="line">MBT_HDR_FLAGS EQU 0x00010003</span><br><span class="line">MBT_HDR_MAGIC EQU 0x1BADB002 ;多引导协议头魔数</span><br><span class="line">MBT_HDR2_MAGIC EQU 0xe85250d6 ;第二版多引导协议头魔数</span><br><span class="line">global _start ;导出_start符号</span><br><span class="line">extern main ;导入外部的main函数符号</span><br><span class="line">[section .start.text] ;定义.start.text代码节</span><br><span class="line">[bits 32] ;汇编成32位代码</span><br><span class="line">_start:</span><br><span class="line">jmp _entry</span><br><span class="line">ALIGN 8</span><br><span class="line">mbt_hdr:</span><br><span class="line">dd MBT_HDR_MAGIC</span><br><span class="line">dd MBT_HDR_FLAGS</span><br><span class="line">dd -(MBT_HDR_MAGIC+MBT_HDR_FLAGS)</span><br><span class="line">dd mbt_hdr</span><br><span class="line">dd _start</span><br><span class="line">dd 0</span><br><span class="line">dd 0</span><br><span class="line">dd _entry</span><br><span class="line">;以上是GRUB所需要的头</span><br><span class="line">ALIGN 8</span><br><span class="line">mbt2_hdr:</span><br><span class="line">DD MBT_HDR2_MAGIC</span><br><span class="line">DD 0</span><br><span class="line">DD mbt2_hdr_end - mbt2_hdr</span><br><span class="line">DD -(MBT_HDR2_MAGIC + 0 + (mbt2_hdr_end - mbt2_hdr))</span><br><span class="line">DW 2, 0</span><br><span class="line">DD 24</span><br><span class="line">DD mbt2_hdr</span><br><span class="line">DD _start</span><br><span class="line">DD 0</span><br><span class="line">DD 0</span><br><span class="line">DW 3, 0</span><br><span class="line">DD 12</span><br><span class="line">DD _entry</span><br><span class="line">DD 0</span><br><span class="line">DW 0, 0</span><br><span class="line">DD 8</span><br><span class="line">mbt2_hdr_end:</span><br><span class="line">;以上是GRUB2所需要的头</span><br><span class="line">;包含两个头是为了同时兼容GRUB、GRUB2</span><br><span class="line">ALIGN 8</span><br><span class="line">_entry:</span><br><span class="line">;关中断</span><br><span class="line">cli</span><br><span class="line">;关不可屏蔽中断</span><br><span class="line">in al, 0x70</span><br><span class="line">or al, 0x80</span><br><span class="line">out 0x70,al</span><br><span class="line">;重新加载GDT</span><br><span class="line">lgdt [GDT_PTR]</span><br><span class="line">jmp dword 0x8 :_32bits_mode</span><br><span class="line">_32bits_mode:</span><br><span class="line">;下面初始化C语言可能会用到的寄存器</span><br><span class="line">mov ax, 0x10</span><br><span class="line">mov ds, ax</span><br><span class="line">mov ss, ax</span><br><span class="line">mov es, ax</span><br><span class="line">mov fs, ax</span><br><span class="line">mov gs, ax</span><br><span class="line">xor eax,eax</span><br><span class="line">xor ebx,ebx</span><br><span class="line">xor ecx,ecx</span><br><span class="line">xor edx,edx</span><br><span class="line">xor edi,edi</span><br><span class="line">xor esi,esi</span><br><span class="line">xor ebp,ebp</span><br><span class="line">xor esp,esp</span><br><span class="line">;初始化栈，C语言需要栈才能工作</span><br><span class="line">mov esp,0x9000</span><br><span class="line">;调用C语言函数main</span><br><span class="line">call main</span><br><span class="line">;让CPU停止执行指令</span><br><span class="line">halt_step:</span><br><span class="line">halt</span><br><span class="line">jmp halt_step</span><br><span class="line">GDT_START:</span><br><span class="line">knull_dsc: dq 0</span><br><span class="line">kcode_dsc: dq 0x00cf9e000000ffff</span><br><span class="line">kdata_dsc: dq 0x00cf92000000ffff</span><br><span class="line">k16cd_dsc: dq 0x00009e000000ffff</span><br><span class="line">k16da_dsc: dq 0x000092000000ffff</span><br><span class="line">GDT_END:</span><br><span class="line">GDT_PTR:</span><br><span class="line">GDTLEN dw GDT_END-GDT_START-1</span><br><span class="line">GDTBASE dd GDT_START</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上的汇编代码（&#x2F;lesson02&#x2F;HelloOS&#x2F;entry.asm）分为4个部分：</p><p>1.代码1~40行，用汇编定义的GRUB的多引导协议头，其实就是一定格式的数据，我们的Hello OS是用GRUB引导的，当然要遵循 <strong>GRUB的多引导协议标准</strong>，让GRUB能识别我们的Hello OS。之所以有两个引导头，是为了兼容GRUB1和GRUB2。</p><p>2.代码44~52行，关掉中断，设定CPU的工作模式。你现在可能不懂，没事儿，后面CPU相关的课程我们会专门再研究它。</p><p>3.代码54~73行，初始化CPU的寄存器和C语言的运行环境。</p><p>4.代码78~87行，GDT_START开始的，是CPU工作模式所需要的数据，同样，后面讲CPU时会专门介绍。</p><h2 id="Hello-OS的主函数"><a href="#Hello-OS的主函数" class="headerlink" title="Hello OS的主函数"></a>Hello OS的主函数</h2><p>到这，不知道你有没有发现一个问题?上面的汇编代码调用了main函数，而在其代码中并没有看到其函数体，而是从外部引入了一个符号。</p><p>那是因为这个函数是用C语言写的在（&#x2F;lesson02&#x2F;HelloOS&#x2F;main.c）中，最终它们分别由nasm和GCC编译成可链接模块，由LD链接器链接在一起，形成可执行的程序文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//彭东 @ 2021.01.09</span><br><span class="line">#include &quot;vgastr.h&quot;</span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Hello OS!&quot;);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上这段代码，你应该很熟悉了吧？不过这不是应用程序的main函数，而是Hello OS的main函数。</p><p>其中的printf也不是应用程序库中的那个printf了，而是需要我们自己实现了。你可以先停下歇歇，再去实现printf函数。</p><h2 id="控制计算机屏幕"><a href="#控制计算机屏幕" class="headerlink" title="控制计算机屏幕"></a>控制计算机屏幕</h2><p>接着我们再看下显卡，这和我们接下来要写的代码有直接关联。</p><p>计算机屏幕显示往往是显卡的输出，显卡有很多形式：集成在主板的叫集显，做在CPU芯片内的叫核显，独立存在通过PCIE接口连接的叫独显，性能依次上升，价格也是。</p><p>独显的高性能是游戏玩家们所钟爱的，3D图形显示往往要涉及顶点处理、多边形的生成和变换、纹理、着色、打光、栅格化等。而这些任务的计算量超级大，所以独显往往有自己的RAM、多达几百个运算核心的处理器。因此独显不仅仅是可以显示图像，而且可以执行大规模并行计算，比如“挖矿”。</p><p>我们要在屏幕上显示字符，就要编程操作显卡。</p><p>其实无论我们PC上是什么显卡，它们都支持一种叫 <strong>VESA</strong> 的标准，这种标准下有两种工作模式：字符模式和图形模式。显卡们为了兼容这种标准，不得不自己提供一种叫VGABIOS的固件程序。</p><p>下面，我们来看看显卡的字符模式的工作细节。</p><p>它把屏幕分成24行，每行80个字符，把这（24*80）个位置映射到以0xb8000地址开始的内存中，每两个字节对应一个字符，其中一个字节是字符的ASCII码，另一个字节为字符的颜色值。如下图所示：</p><p><img src="/images/369502/782ef574b96084fa44a33ea1f83146f5.jpg"></p><p>明白了显卡的字符模式的工作细节，下面我们开始写代码。</p><p>这里先提个醒： <strong>C语言字符串是以0结尾的，其字符编码通常是utf8，而utf8编码对ASCII字符是兼容的，即英文字符的ASCII编码和utf8编码是相等的</strong>（关于 <a href="https://www.utf8.com/">utf8</a> 编码你可以自行了解）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//彭东 @ 2021.01.09</span><br><span class="line">void _strwrite(char* string)</span><br><span class="line">&#123;</span><br><span class="line">  char* p_strdst = (char*)(0xb8000);//指向显存的开始地址</span><br><span class="line">  while (*string)</span><br><span class="line">  &#123;</span><br><span class="line">    *p_strdst = *string++;</span><br><span class="line">    p_strdst += 2;</span><br><span class="line">  &#125;</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void printf(char* fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">  _strwrite(fmt);</span><br><span class="line">  return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>代码很简单，printf函数直接调用了_strwrite函数，而_strwrite函数正是将字符串里每个字符依次定入到0xb8000地址开始的显存中，而p_strdst每次加2，这也是为了跳过字符的颜色信息的空间。</p><p>到这，Hello OS相关的代码就写好了，下面就是编译和安装了。你可别以为这个事情就简单了，下面请跟着我去看一看。</p><h2 id="编译和安装Hello-OS"><a href="#编译和安装Hello-OS" class="headerlink" title="编译和安装Hello OS"></a>编译和安装Hello OS</h2><p>Hello OS的代码都已经写好，这时就要进入安装测试环节了。在安装之前，我们要进行系统编译，即把每个代码模块编译最后链接成可执行的二进制文件。</p><p>你可能觉得我在小题大做，编译不就是输入几条命令吗，这么简单的工作也值得一说？</p><p>确实，对于我们Hello OS的编译工作来说特别简单，因为总共才三个代码文件，最多四条命令就可以完成。</p><p>但是以后我们Hello OS的文件数量会爆炸式增长，一个成熟的商业操作系统更是多达几万个代码模块文件，几千万行的代码量，是这世间最复杂的软件工程之一。所以需要一个牛逼的工具来控制这个巨大的编译过程。</p><h2 id="make工具"><a href="#make工具" class="headerlink" title="make工具"></a>make工具</h2><p>make历史悠久，小巧方便，也是很多成熟操作系统编译所使用的构建工具。</p><p>在软件开发中，make是一个工具程序，它读取一个叫“makefile”的文件，也是一种文本文件，这个文件中写好了构建软件的规则，它能根据这些规则自动化构建软件。</p><p>makefile文件中规则是这样的：首先有一个或者多个构建目标称为“target”；目标后面紧跟着用于构建该目标所需要的文件，目标下面是构建该目标所需要的命令及参数。</p><p>与此同时，它也检查文件的依赖关系，如果需要的话，它会调用一些外部软件来完成任务。</p><p>第一次构建目标后，下一次执行make时，它会根据该目标所依赖的文件是否更新决定是否编译该目标，如果所依赖的文件没有更新且该目标又存在，那么它便不会构建该目标。这种特性非常有利于编译程序源代码。</p><p>任何一个Linux发行版中都默认自带这个make程序，所以不需要额外的安装工作，我们直接使用即可。</p><p>为了让你进一步了解make的使用，接下来我们一起看一个有关makefile的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CC = gcc #定义一个宏CC 等于gcc</span><br><span class="line">CFLAGS = -c #定义一个宏 CFLAGS 等于-c</span><br><span class="line">OBJS_FILE = file.o file1.o file2.o file3.o file4.o #定义一个宏</span><br><span class="line">.PHONY : all everything #定义两个伪目标all、everything</span><br><span class="line">all:everything #伪目标all依赖于伪目标everything</span><br><span class="line">everything :$(OBJS_FILE) #伪目标everything依赖于OBJS_FILE，而OBJS_FILE是宏会被</span><br><span class="line">#替换成file.o file1.o file2.o file3.o file4.o</span><br><span class="line">%.o : %.c</span><br><span class="line">   $(CC) $(CFLAGS) -o $@ $&lt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我来解释一下这个例子：</p><p>make规定“#”后面为注释，make处理makefile时会自动丢弃。</p><p>makefile中可以定义宏，方法是 <strong>在一个字符串后跟一个“&#x3D;”或者“:&#x3D;”符号</strong>，引用宏时要用“$(宏名)”，宏最终会在宏出现的地方替换成相应的字符串，例如：$(CC)会被替换成gcc，$( OBJS_FILE) 会被替换成file.o file1.o file2.o file3.o file4.o。</p><p>.PHONY在makefile中表示定义伪目标。所谓伪目标，就是它不代表一个真正的文件名，在执行make时可以指定这个目标来执行其所在规则定义的命令。但是伪目标可以依赖于另一个伪目标或者文件，例如：all依赖于everything，everything最终依赖于file.c file1.c file2.c file3.c file4.c。</p><p>虽然我们会发现，everything下面并没有相关的执行命令，但是下面有个通用规则：“%.o : %.c”。其中的“%”表示通配符，表示所有以“.o”结尾的文件依赖于所有以“.c”结尾的文件。</p><p>例如：file.c、file1.c、file2.c、file3.c、file4.c，通过这个通用规则会自动转换为依赖关系：file.o: file.c、file1.o: file1.c、file2.o: file2.c、file3.o: file3.c、file4.o: file4.c。</p><p>然后，针对这些依赖关系，分别会执行：$(CC) $(CFLAGS) -o $@ $&lt;命令，当然最终会转换为：gcc –c –o xxxx.o xxxx.c，这里的“xxxx”表示一个具体的文件名。</p><h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>下面我们用一张图来描述我们Hello OS的编译过程，如下所示：</p><p><img src="/images/369502/cbd634cd5256e372bcbebd4b95f21b34.jpg"></p><h2 id="安装Hello-OS"><a href="#安装Hello-OS" class="headerlink" title="安装Hello OS"></a>安装Hello OS</h2><p>经过上述流程，我们就会得到Hello OS.bin文件，但是我们还要让GRUB能够找到它，才能在计算机启动时加载它。这个过程我们称为安装，不过这里没有写安装程序，得我们手动来做。</p><p>经研究发现，GRUB在启动时会加载一个grub.cfg的文本文件，根据其中的内容执行相应的操作，其中一部分内容就是启动项。</p><p>GRUB首先会显示启动项到屏幕，然后让我们选择启动项，最后GRUB根据启动项对应的信息，加载OS文件到内存。</p><p>下面来看看我们Hello OS的启动项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#x27;HelloOS&#x27; &#123;</span><br><span class="line">     insmod part_msdos #GRUB加载分区模块识别分区</span><br><span class="line">     insmod ext2 #GRUB加载ext文件系统模块识别ext文件系统</span><br><span class="line">     set root=&#x27;hd0,msdos4&#x27; #注意boot目录挂载的分区，这是我机器上的情况</span><br><span class="line">     multiboot2 /boot/HelloOS.bin #GRUB以multiboot2协议加载HelloOS.bin</span><br><span class="line">     boot #GRUB启动HelloOS.bin</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果你不知道你的boot目录挂载的分区，可以在Linux系统的终端下输入命令：df &#x2F;boot&#x2F;，就会得到如下结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">文件系统          1K-块    已用     可用      已用% 挂载点</span><br><span class="line">/dev/sda4      48752308 8087584 38158536   18%    /</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中的“sda4”就是硬盘的第四个分区（硬件分区选择MBR），但是GRUB的menuentry中不能写sda4，而是要写“hd0,msdos4”，这是GRUB的命名方式，hd0表示第一块硬盘，结合起来就是第一块硬盘的第四个分区。</p><p>把上面启动项的代码插入到你的Linux机器上的&#x2F;boot&#x2F;grub&#x2F;grub.cfg文件末尾，然后把Hello OS.bin文件复制到&#x2F;boot&#x2F;目录下，一定注意 <strong>这里是追加不是覆盖</strong>。最后重启计算机，你就可以看到Hello OS的启动选项了。</p><p>选择Hello OS，按下Enter键（或者重启按ESC键），这样就可以成功启动我们自己的Hello OS了。</p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>有没有很开心？我们终于看到我们自己的OS运行了，就算它再简单也是我们自己的OS。下面我们再次回顾下这节课的重点。</p><p>首先，我们了解了从按下PC机电源开关开始，PC机的引导过程。它从CPU上电，到加载BIOS固件，再由BIOS固件对计算机进行自检和默认的初始化，并加载GRUB引导程序，最后由GRUB加载具体的操作系统。</p><p>其次，就到了我们这节课最难的部分，即用汇编语言和C语言实现我们的Hello OS。</p><p>第一步，用汇编程序初始化CPU的寄存器、设置CPU的工作模式和栈，最重要的是 <strong>加入了GRUB引导协议头</strong>；第二步，切换到C语言，用C语言写好了 <strong>主函数和控制显卡输出的函数</strong>，其间还了解了显卡的一些工作细节。</p><p>最后，就是编译和安装Hello OS了。我们用了make工具编译整个代码，其实make会根据一些规则调用具体的nasm、gcc、ld等编译器，然后形成Hello OS.bin文件，你把这个文件写复制到boot分区，写好GRUB启动项，这样就好了。</p><p>这里只是上上手，下面我们还会去准备一些别的东西，然后就真正开始了。但你此刻也许还有很多问题没有搞清楚，比如重新加载GDT、关中断等，先不要担心，我们后面会一一解决的。</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>以上printf函数定义，其中有个形式参数很奇怪，请你思考下：为什么是“…”形式参数，这个形式参数有什么作用？</p><p>欢迎你在留言区分享你的思考或疑问。</p><p>我是LMOS，我们下节课见！</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>代码块演示</title>
      <link href="/2023/09/05/codeshow/cpp/"/>
      <url>/2023/09/05/codeshow/cpp/</url>
      
        <content type="html"><![CDATA[<h1 id="01-程序的运行过程：从代码到机器运行"><a href="#01-程序的运行过程：从代码到机器运行" class="headerlink" title="01 | 程序的运行过程：从代码到机器运行"></a>01 | 程序的运行过程：从代码到机器运行</h1><p>你好，我是LMOS。<br><img src="https://picsum.photos/750/400" alt="图片名称描述开启"><br>欢迎来到操作系统第一课。在真正打造操作系统前，有一条必经之路：你知道程序是如何运行的吗？</p><p>一个熟练的编程老手只需肉眼看着代码，就能对其运行的过程了如指掌。但对于初学者来说，这常常是很困难的事，这需要好几年的程序开发经验，和在长期的程序开发过程中对编程基本功的积累。</p><p>我记得自己最初学习操作系统的时候，面对逻辑稍微复杂的一些程序，在编写、调试代码时，就会陷入代码的迷宫，找不到东南西北。</p><p>不知道你现在处在什么阶段，是否曾有同样的感受？ <strong>我常常说，扎实的基本功就像手里的指南针，你可以一步步强大到不依赖它，但是不能没有。</strong></p><p>因此今天，我将带领你从“Hello World”起，扎实基本功，探索程序如何运行的所有细节和原理。这节课的配套代码，你可以从 <a href="https://gitee.com/lmos/cosmos/tree/master/lesson01/HelloWorld">这里</a> 下载。</p><h2 id="一切要从牛人做的牛逼事说起"><a href="#一切要从牛人做的牛逼事说起" class="headerlink" title="一切要从牛人做的牛逼事说起"></a>一切要从牛人做的牛逼事说起</h2><p><strong>第一位牛人，是世界级计算机大佬的传奇——Unix之父Ken Thompson</strong>。</p><p>在上世纪60年代的一个夏天，Ken Thompson的妻子要回娘家一个月。呆在贝尔实验室的他，竟然利用这极为孤独的一个月，开发出了UNiplexed Information and Computing System（UNICS）——即UNIX的雏形，一个全新的操作系统。</p><p>要知道，在当时C语言并没有诞生，从严格意义上说，他是用B语言和汇编语言在PDP-7的机器上完成的。</p><p><img src="/images/369457/418b94aed8aab2abf6538a103d9f2856.png"></p><p><strong>牛人的朋友也是牛人，他的朋友Dennis Ritchie也随之加入其中，共同创造了大名鼎鼎的C语言，并用C语言写出了UNIX和后来的类UNIX体系的几十种操作系统，也写出了对后世影响深远的第一版“Hello World”</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;stdio.h&quot;</span><br><span class="line">int main(int argc, char const *argv[])</span><br><span class="line">&#123;</span><br><span class="line">  printf(&quot;Hello World!\n&quot;);</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>计算机硬件是无法直接运行这个C语言文本程序代码的，需要C语言编译器，把这个代码编译成具体硬件平台的二进制代码。再由具体操作系统建立进程，把这个二进制文件装进其进程的内存空间中，才能运行。</p><p>听起来很复杂？别急，接着往下看。</p><h2 id="程序编译过程"><a href="#程序编译过程" class="headerlink" title="程序编译过程"></a>程序编译过程</h2><p>我们暂且不急着摸清操作系统所做的工作，先来研究一下编译过程和硬件执行程序的过程，约定使用GCC相关的工具链。</p><p>那么使用命令：gcc HelloWorld.c -o HelloWorld 或者 gcc .&#x2F;HelloWorld.c -o .&#x2F;HelloWorld ，就可以编译这段代码。其实，GCC只是完成编译工作的驱动程序，它会根据编译流程分别调用预处理程序、编译程序、汇编程序、链接程序来完成具体工作。</p><p>下图就是编译这段代码的过程：</p><p><img src="/images/369457/f2b10135ed52436888a793327e4d5a4a.jpg"></p><p>其实，我们也可以手动控制以上这个编译流程，从而留下中间文件方便研究：</p><ul><li>gcc HelloWorld.c -E -o HelloWorld.i预处理：加入头文件，替换宏。</li><li>gcc HelloWorld.c -S -c -o HelloWorld.s编译：包含预处理，将C程序转换成汇编程序。</li><li>gcc HelloWorld.c -c -o HelloWorld.o汇编：包含预处理和编译，将汇编程序转换成可链接的二进制程序。</li><li>gcc HelloWorld.c -o HelloWorld链接：包含以上所有操作，将可链接的二进制程序和其它别的库链接在一起，形成可执行的程序文件。</li></ul><h2 id="程序装载执行"><a href="#程序装载执行" class="headerlink" title="程序装载执行"></a>程序装载执行</h2><p>对运行内容有了了解后，我们开始程序的装载执行。</p><p>我们将请出 <strong>第三位牛人——大名鼎鼎的阿兰·图灵。在他的众多贡献中，很重要的一个就是提出了一种理想中的机器：图灵机。</strong></p><p>图灵机是一个抽象的模型，它是这样的：有一条无限长的纸带，纸带上有无限个小格子，小格子中写有相关的信息，纸带上有一个读头，读头能根据纸带小格子里的信息做相关的操作并能来回移动。</p><p>文字叙述还不够形象，我们来画一幅插图：</p><p><img src="/images/369457/6914497643dbb0aaefffc32b865dcf7d.png"></p><p>不理解？下面我再带你用图灵机执行一下“1+1&#x3D;2”的计算，你就明白了。我们定义读头读到“+”之后，就依次移动读头两次并读取格子中的数据，最后读头计算把结果写入第二个数据的下一个格子里，整个过程如下图：</p><p><img src="/images/369457/43812abfe104d6885815825f07622e87.jpg"></p><p>这个理想的模型是好，但是理想终归是理想，想要成为现实，我们得想其它办法。</p><p><strong>于是，第四位牛人来了，他提出了电子计算机使用二进制数制系统和储存程序，并按照程序顺序执行，他叫冯诺依曼，他的电子计算机理论叫冯诺依曼体系结构。</strong></p><p>根据冯诺依曼体系结构构成的计算机，必须具有如下功能：</p><ul><li>把程序和数据装入到计算机中；</li><li>必须具有长期记住程序、数据的中间结果及最终运算结果；</li><li>完成各种算术、逻辑运算和数据传送等数据加工处理；</li><li>根据需要控制程序走向，并能根据指令控制机器的各部件协调操作；</li><li>能够按照要求将处理的数据结果显示给用户。</li></ul><p>为了完成上述的功能，计算机必须具备五大基本组成部件：</p><ul><li>装载数据和程序的输入设备；</li><li>记住程序和数据的存储器；</li><li>完成数据加工处理的运算器；</li><li>控制程序执行的控制器；</li><li>显示处理结果的输出设备。</li></ul><p>根据冯诺依曼的理论，我们只要把图灵机的几个部件换成电子设备，就可以变成一个最小核心的电子计算机，如下图：</p><p><img src="/images/369457/bde34df011c397yy42dc00fe6bd35226.jpg"></p><p>是不是非常简单？这次我们发现读头不再来回移动了，而是靠地址总线寻找对应的“纸带格子”。读取写入数据由数据总线完成，而动作的控制就是控制总线的职责了。</p><h2 id="更形象地将HelloWorld程序装入原型计算机"><a href="#更形象地将HelloWorld程序装入原型计算机" class="headerlink" title="更形象地将HelloWorld程序装入原型计算机"></a>更形象地将HelloWorld程序装入原型计算机</h2><p>下面，我们尝试将HelloWorld程序装入这个原型计算机，在装入之前，我们先要搞清楚HelloWorld程序中有什么。</p><p>我们可以通过gcc -c -S HelloWorld得到（只能得到其汇编代码，而不能得到二进制数据）。我们用objdump -d HelloWorld程序，得到&#x2F;lesson01&#x2F;HelloWorld.dump，其中有很多库代码（只需关注main函数相关的代码），如下图：</p><p><img src="/images/369457/3991a042107b90612122b14596c65614.jpeg"></p><p>以上图中，分成四列：第一列为地址；第二列为十六进制，表示真正装入机器中的代码数据；第三列是对应的汇编代码；第四列是相关代码的注释。这是x86_64体系的代码，由此可以看出x86 CPU是变长指令集。</p><p>接下来，我们把这段代码数据装入最小电子计算机，状态如下图：</p><p><img src="/images/369457/5d4889e7bf20e670ee71cc9b6285c96e.jpg"></p><h2 id="重点回顾"><a href="#重点回顾" class="headerlink" title="重点回顾"></a>重点回顾</h2><p>以上，对应图中的伪代码你应该明白了：现代电子计算机正是通过内存中的信息（指令和数据）做出相应的操作，并通过内存地址的变化，达到程序读取数据，控制程序流程（顺序、跳转对应该图灵机的读头来回移动）的功能。</p><p>这和图灵机的核心思想相比，没有根本性的变化。只要配合一些I&#x2F;O设备，让用户输入并显示计算结果给用户，就是一台现代意义的电子计算机。</p><p>到这里，我们理清了程序运行的所有细节和原理。还有一点，你可能有点疑惑，即printf对应的puts函数，到底做了什么？而这正是我们后面的课程要探索的！</p><h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p>为了实现C语言中函数的调用和返回功能，CPU实现了函数调用和返回指令，即上图汇编代码中的“call”，“ret”指令，请你思考一下：call和ret指令在逻辑上执行的操作是怎样的呢？</p><p>期待你在留言区跟我交流互动。如果这节课对你有所启发，也欢迎转发给你的朋友、同事，跟他们一起学习进步。</p><p>这是一段C++代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//Linux -lpthread</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">bool</span> is_exit = <span class="literal">false</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ThreadMain</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;begin sub thread main &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!is_exit) <span class="keyword">break</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;in thread &quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));<span class="comment">//1000ms</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;end sub thread main &quot;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//thread th(ThreadMain); //出错，thread对象被销毁 子线程还在运行</span></span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">th</span><span class="params">(ThreadMain)</span></span>;</span><br><span class="line">th.<span class="built_in">detach</span>(); <span class="comment">//子线程与主线程分离 守护线程</span></span><br><span class="line"><span class="comment">//坑 ：主线程退出后 子线程不一定退出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="function">thread <span class="title">th</span><span class="params">(ThreadMain)</span></span>;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));<span class="comment">//1000ms</span></span><br><span class="line">is_exit = <span class="literal">true</span>; <span class="comment">//通知子线程退出</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;主线程阻塞，等待子线程退出&quot;</span> &lt;&lt; endl;</span><br><span class="line">th.<span class="built_in">join</span>(); <span class="comment">//主线程阻塞，等待子线程退出</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;子线程已经退出！&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">getchar</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> boke </tag>
            
            <tag> code </tag>
            
            <tag> daima </tag>
            
            <tag> jhhhh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/09/04/hello-world/"/>
      <url>/2023/09/04/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
